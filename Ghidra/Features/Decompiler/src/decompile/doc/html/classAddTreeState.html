<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>decompiler: AddTreeState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classAddTreeState-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AddTreeState Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Structure for sorting out pointer expression trees.  
 <a href="classAddTreeState.html#details">More...</a></p>

<p><code>#include &lt;ruleaction.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a185c2380f854f4355176454d2bb0f9c8"><td class="memItemLeft" align="right" valign="top"><a id="a185c2380f854f4355176454d2bb0f9c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a185c2380f854f4355176454d2bb0f9c8">AddTreeState</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;d, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot)</td></tr>
<tr class="memdesc:a185c2380f854f4355176454d2bb0f9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct given root of ADD tree and pointer. <br /></td></tr>
<tr class="separator:a185c2380f854f4355176454d2bb0f9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fba7b1b0b2a97ada10a8a59ab2e6cd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">apply</a> (void)</td></tr>
<tr class="memdesc:a1fba7b1b0b2a97ada10a8a59ab2e6cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to transform the pointer expression.  <a href="classAddTreeState.html#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">More...</a><br /></td></tr>
<tr class="separator:a1fba7b1b0b2a97ada10a8a59ab2e6cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc12ebd25e5593a37fcff5d61ef8e4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#adcc12ebd25e5593a37fcff5d61ef8e4c">initAlternateForm</a> (void)</td></tr>
<tr class="memdesc:adcc12ebd25e5593a37fcff5d61ef8e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare analysis if there is an alternate form of the base pointer.  <a href="classAddTreeState.html#adcc12ebd25e5593a37fcff5d61ef8e4c">More...</a><br /></td></tr>
<tr class="separator:adcc12ebd25e5593a37fcff5d61ef8e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aeedff321c0b98b2861dc69e3e55d4587"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#aeedff321c0b98b2861dc69e3e55d4587">findArrayHint</a> (void) const</td></tr>
<tr class="memdesc:aeedff321c0b98b2861dc69e3e55d4587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for evidence of an array in a sub-component.  <a href="classAddTreeState.html#aeedff321c0b98b2861dc69e3e55d4587">More...</a><br /></td></tr>
<tr class="separator:aeedff321c0b98b2861dc69e3e55d4587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc50e0482c67c1c00315a04ad982a8d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#acc50e0482c67c1c00315a04ad982a8d2">hasMatchingSubType</a> (uintb off, uint4 arrayHint, uintb *newoff) const</td></tr>
<tr class="memdesc:acc50e0482c67c1c00315a04ad982a8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an offset into the base data-type and array hints find sub-component being referenced.  <a href="classAddTreeState.html#acc50e0482c67c1c00315a04ad982a8d2">More...</a><br /></td></tr>
<tr class="separator:acc50e0482c67c1c00315a04ad982a8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2300dc2f7b523f2e5ffce74b2cffd6cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a2300dc2f7b523f2e5ffce74b2cffd6cb">checkMultTerm</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, uintb treeCoeff)</td></tr>
<tr class="memdesc:a2300dc2f7b523f2e5ffce74b2cffd6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate details of INT_MULT term and continue traversal if appropriate.  <a href="classAddTreeState.html#a2300dc2f7b523f2e5ffce74b2cffd6cb">More...</a><br /></td></tr>
<tr class="separator:a2300dc2f7b523f2e5ffce74b2cffd6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa761a9df6d8565da907989a6ab7fbc83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#aa761a9df6d8565da907989a6ab7fbc83">checkTerm</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, uintb treeCoeff)</td></tr>
<tr class="memdesc:aa761a9df6d8565da907989a6ab7fbc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate details of given term and continue tree traversal.  <a href="classAddTreeState.html#aa761a9df6d8565da907989a6ab7fbc83">More...</a><br /></td></tr>
<tr class="separator:aa761a9df6d8565da907989a6ab7fbc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3444f0e74e13ce9f6cfc5c7b5017ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#afd3444f0e74e13ce9f6cfc5c7b5017ba">spanAddTree</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, uintb treeCoeff)</td></tr>
<tr class="memdesc:afd3444f0e74e13ce9f6cfc5c7b5017ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the given sub-tree accumulating details.  <a href="classAddTreeState.html#afd3444f0e74e13ce9f6cfc5c7b5017ba">More...</a><br /></td></tr>
<tr class="separator:afd3444f0e74e13ce9f6cfc5c7b5017ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4703469da7955c4df9c11ec8872a7604"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a4703469da7955c4df9c11ec8872a7604">calcSubtype</a> (void)</td></tr>
<tr class="memdesc:a4703469da7955c4df9c11ec8872a7604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate final sub-type offset.  <a href="classAddTreeState.html#a4703469da7955c4df9c11ec8872a7604">More...</a><br /></td></tr>
<tr class="separator:a4703469da7955c4df9c11ec8872a7604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8a6c35f777edd060cfd319382bfeec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a8e8a6c35f777edd060cfd319382bfeec">buildMultiples</a> (void)</td></tr>
<tr class="memdesc:a8e8a6c35f777edd060cfd319382bfeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build part of tree that is multiple of base size.  <a href="classAddTreeState.html#a8e8a6c35f777edd060cfd319382bfeec">More...</a><br /></td></tr>
<tr class="separator:a8e8a6c35f777edd060cfd319382bfeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406b886ea345f99dd568813650c73f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a406b886ea345f99dd568813650c73f0f">buildExtra</a> (void)</td></tr>
<tr class="memdesc:a406b886ea345f99dd568813650c73f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build part of tree not accounted for by multiples or <em>offset</em>.  <a href="classAddTreeState.html#a406b886ea345f99dd568813650c73f0f">More...</a><br /></td></tr>
<tr class="separator:a406b886ea345f99dd568813650c73f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c93f07dbbb6152187d0111ee2c3374e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a2c93f07dbbb6152187d0111ee2c3374e">buildDegenerate</a> (void)</td></tr>
<tr class="memdesc:a2c93f07dbbb6152187d0111ee2c3374e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform ADD into degenerate PTRADD.  <a href="classAddTreeState.html#a2c93f07dbbb6152187d0111ee2c3374e">More...</a><br /></td></tr>
<tr class="separator:a2c93f07dbbb6152187d0111ee2c3374e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f392e1525b28ab09bfda8c210bff22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">buildTree</a> (void)</td></tr>
<tr class="memdesc:a8f392e1525b28ab09bfda8c210bff22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the transformed ADD tree.  <a href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">More...</a><br /></td></tr>
<tr class="separator:a8f392e1525b28ab09bfda8c210bff22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb9ea80291a7506d29331ad2fb0d5f6"><td class="memItemLeft" align="right" valign="top"><a id="aadb9ea80291a7506d29331ad2fb0d5f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#aadb9ea80291a7506d29331ad2fb0d5f6">clear</a> (void)</td></tr>
<tr class="memdesc:aadb9ea80291a7506d29331ad2fb0d5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset for a new ADD tree traversal. <br /></td></tr>
<tr class="separator:aadb9ea80291a7506d29331ad2fb0d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad2ad5d874a5453682ddd72058476add4"><td class="memItemLeft" align="right" valign="top"><a id="ad2ad5d874a5453682ddd72058476add4"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#ad2ad5d874a5453682ddd72058476add4">data</a></td></tr>
<tr class="memdesc:ad2ad5d874a5453682ddd72058476add4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function containing the expression. <br /></td></tr>
<tr class="separator:ad2ad5d874a5453682ddd72058476add4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e2c67486167d2077bff227c2ebc136"><td class="memItemLeft" align="right" valign="top"><a id="a55e2c67486167d2077bff227c2ebc136"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a55e2c67486167d2077bff227c2ebc136">baseOp</a></td></tr>
<tr class="memdesc:a55e2c67486167d2077bff227c2ebc136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base of the ADD tree. <br /></td></tr>
<tr class="separator:a55e2c67486167d2077bff227c2ebc136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bd4ef288bdc8a93a620c4aec983668"><td class="memItemLeft" align="right" valign="top"><a id="a18bd4ef288bdc8a93a620c4aec983668"></a>
<a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a18bd4ef288bdc8a93a620c4aec983668">ptr</a></td></tr>
<tr class="memdesc:a18bd4ef288bdc8a93a620c4aec983668"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer varnode. <br /></td></tr>
<tr class="separator:a18bd4ef288bdc8a93a620c4aec983668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d5562dcb2c9feb9161e09388b29e0a"><td class="memItemLeft" align="right" valign="top"><a id="ae4d5562dcb2c9feb9161e09388b29e0a"></a>
const <a class="el" href="classTypePointer.html">TypePointer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#ae4d5562dcb2c9feb9161e09388b29e0a">ct</a></td></tr>
<tr class="memdesc:ae4d5562dcb2c9feb9161e09388b29e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer data-type. <br /></td></tr>
<tr class="separator:ae4d5562dcb2c9feb9161e09388b29e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eed9d205c5068f8d2c6ec8d8b7c6c17"><td class="memItemLeft" align="right" valign="top"><a id="a9eed9d205c5068f8d2c6ec8d8b7c6c17"></a>
const <a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a9eed9d205c5068f8d2c6ec8d8b7c6c17">baseType</a></td></tr>
<tr class="memdesc:a9eed9d205c5068f8d2c6ec8d8b7c6c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base data-type being pointed at. <br /></td></tr>
<tr class="separator:a9eed9d205c5068f8d2c6ec8d8b7c6c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed976b05bd05c54f2dc07128eadb68cd"><td class="memItemLeft" align="right" valign="top"><a id="aed976b05bd05c54f2dc07128eadb68cd"></a>
const <a class="el" href="classTypePointerRel.html">TypePointerRel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#aed976b05bd05c54f2dc07128eadb68cd">pRelType</a></td></tr>
<tr class="memdesc:aed976b05bd05c54f2dc07128eadb68cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy of <b>ct</b>, if it is a relative pointer. <br /></td></tr>
<tr class="separator:aed976b05bd05c54f2dc07128eadb68cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfd9dac82898583c495af68a3abc07c"><td class="memItemLeft" align="right" valign="top"><a id="a9cfd9dac82898583c495af68a3abc07c"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a9cfd9dac82898583c495af68a3abc07c">ptrsize</a></td></tr>
<tr class="memdesc:a9cfd9dac82898583c495af68a3abc07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the pointer. <br /></td></tr>
<tr class="separator:a9cfd9dac82898583c495af68a3abc07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535bcd4be85c95843d2cae3572e027a3"><td class="memItemLeft" align="right" valign="top"><a id="a535bcd4be85c95843d2cae3572e027a3"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a535bcd4be85c95843d2cae3572e027a3">size</a></td></tr>
<tr class="memdesc:a535bcd4be85c95843d2cae3572e027a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of data-type being pointed to (in address units) or 0 for open ended pointer. <br /></td></tr>
<tr class="separator:a535bcd4be85c95843d2cae3572e027a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf3a3f869268cebf3915efeb86321b2"><td class="memItemLeft" align="right" valign="top"><a id="a0bf3a3f869268cebf3915efeb86321b2"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a0bf3a3f869268cebf3915efeb86321b2">baseSlot</a></td></tr>
<tr class="memdesc:a0bf3a3f869268cebf3915efeb86321b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot of the ADD tree base that is holding the pointer. <br /></td></tr>
<tr class="separator:a0bf3a3f869268cebf3915efeb86321b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c35148b6056028a64505e790c91ad8"><td class="memItemLeft" align="right" valign="top"><a id="a86c35148b6056028a64505e790c91ad8"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a86c35148b6056028a64505e790c91ad8">ptrmask</a></td></tr>
<tr class="memdesc:a86c35148b6056028a64505e790c91ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for modulo calculations in ptr space. <br /></td></tr>
<tr class="separator:a86c35148b6056028a64505e790c91ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4618ca137eb23d6751899ae86aedb989"><td class="memItemLeft" align="right" valign="top"><a id="a4618ca137eb23d6751899ae86aedb989"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a4618ca137eb23d6751899ae86aedb989">offset</a></td></tr>
<tr class="memdesc:a4618ca137eb23d6751899ae86aedb989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes we dig into the base data-type. <br /></td></tr>
<tr class="separator:a4618ca137eb23d6751899ae86aedb989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a339fd19b13515ab9b6d61296428633"><td class="memItemLeft" align="right" valign="top"><a id="a9a339fd19b13515ab9b6d61296428633"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a9a339fd19b13515ab9b6d61296428633">correct</a></td></tr>
<tr class="memdesc:a9a339fd19b13515ab9b6d61296428633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes being double counted. <br /></td></tr>
<tr class="separator:a9a339fd19b13515ab9b6d61296428633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cf1a3308a896062f44f575c79bb161"><td class="memItemLeft" align="right" valign="top"><a id="a33cf1a3308a896062f44f575c79bb161"></a>
vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a33cf1a3308a896062f44f575c79bb161">multiple</a></td></tr>
<tr class="memdesc:a33cf1a3308a896062f44f575c79bb161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Varnodes which are multiples of size. <br /></td></tr>
<tr class="separator:a33cf1a3308a896062f44f575c79bb161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3516e22467cf77aefe32c9e7f209767"><td class="memItemLeft" align="right" valign="top"><a id="aa3516e22467cf77aefe32c9e7f209767"></a>
vector&lt; intb &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#aa3516e22467cf77aefe32c9e7f209767">coeff</a></td></tr>
<tr class="memdesc:aa3516e22467cf77aefe32c9e7f209767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associated constant multiple. <br /></td></tr>
<tr class="separator:aa3516e22467cf77aefe32c9e7f209767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11cb69f9f85a57c23ddd3fe369bfbff"><td class="memItemLeft" align="right" valign="top"><a id="ac11cb69f9f85a57c23ddd3fe369bfbff"></a>
vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#ac11cb69f9f85a57c23ddd3fe369bfbff">nonmult</a></td></tr>
<tr class="memdesc:ac11cb69f9f85a57c23ddd3fe369bfbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Varnodes which are not multiples. <br /></td></tr>
<tr class="separator:ac11cb69f9f85a57c23ddd3fe369bfbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5ba0f36d298e714b6d225d32b3dcbb"><td class="memItemLeft" align="right" valign="top"><a id="aaf5ba0f36d298e714b6d225d32b3dcbb"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#aaf5ba0f36d298e714b6d225d32b3dcbb">distributeOp</a></td></tr>
<tr class="memdesc:aaf5ba0f36d298e714b6d225d32b3dcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CPUI_INT_MULT op that needs to be distributed. <br /></td></tr>
<tr class="separator:aaf5ba0f36d298e714b6d225d32b3dcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfd064f5fab88778d1a82d6e1bf210c"><td class="memItemLeft" align="right" valign="top"><a id="acbfd064f5fab88778d1a82d6e1bf210c"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#acbfd064f5fab88778d1a82d6e1bf210c">multsum</a></td></tr>
<tr class="memdesc:acbfd064f5fab88778d1a82d6e1bf210c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of multiple constants. <br /></td></tr>
<tr class="separator:acbfd064f5fab88778d1a82d6e1bf210c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0673da5a1c73b83c06a96730b3676778"><td class="memItemLeft" align="right" valign="top"><a id="a0673da5a1c73b83c06a96730b3676778"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a0673da5a1c73b83c06a96730b3676778">nonmultsum</a></td></tr>
<tr class="memdesc:a0673da5a1c73b83c06a96730b3676778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of non-multiple constants. <br /></td></tr>
<tr class="separator:a0673da5a1c73b83c06a96730b3676778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02abd1fcfed7249def1749088b2cec1f"><td class="memItemLeft" align="right" valign="top"><a id="a02abd1fcfed7249def1749088b2cec1f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a02abd1fcfed7249def1749088b2cec1f">preventDistribution</a></td></tr>
<tr class="memdesc:a02abd1fcfed7249def1749088b2cec1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not distribute "multiply by constant" operation. <br /></td></tr>
<tr class="separator:a02abd1fcfed7249def1749088b2cec1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b979fc2578a1f8c6d1801fdf79d5f4a"><td class="memItemLeft" align="right" valign="top"><a id="a7b979fc2578a1f8c6d1801fdf79d5f4a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a7b979fc2578a1f8c6d1801fdf79d5f4a">isDistributeUsed</a></td></tr>
<tr class="memdesc:a7b979fc2578a1f8c6d1801fdf79d5f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are terms produced by distributing used. <br /></td></tr>
<tr class="separator:a7b979fc2578a1f8c6d1801fdf79d5f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbaaa799adf8efd5b70948a5245c0b1"><td class="memItemLeft" align="right" valign="top"><a id="abcbaaa799adf8efd5b70948a5245c0b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#abcbaaa799adf8efd5b70948a5245c0b1">isSubtype</a></td></tr>
<tr class="memdesc:abcbaaa799adf8efd5b70948a5245c0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is there a sub-type (using CPUI_PTRSUB) <br /></td></tr>
<tr class="separator:abcbaaa799adf8efd5b70948a5245c0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac866a2b0c8bd9cb9e30840195a70293"><td class="memItemLeft" align="right" valign="top"><a id="aac866a2b0c8bd9cb9e30840195a70293"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#aac866a2b0c8bd9cb9e30840195a70293">valid</a></td></tr>
<tr class="memdesc:aac866a2b0c8bd9cb9e30840195a70293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to <b>true</b> if the whole expression can be transformed. <br /></td></tr>
<tr class="separator:aac866a2b0c8bd9cb9e30840195a70293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2d0ce2fb20f76f64cb5c6aafd51204"><td class="memItemLeft" align="right" valign="top"><a id="a4a2d0ce2fb20f76f64cb5c6aafd51204"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html#a4a2d0ce2fb20f76f64cb5c6aafd51204">isDegenerate</a></td></tr>
<tr class="memdesc:a4a2d0ce2fb20f76f64cb5c6aafd51204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to <b>true</b> if pointer to unitsize or smaller. <br /></td></tr>
<tr class="separator:a4a2d0ce2fb20f76f64cb5c6aafd51204"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structure for sorting out pointer expression trees. </p>
<p>Given a base pointer of known data-type and an additive expression involving the pointer, group the terms of the expression into:</p><ul>
<li>A constant multiple of the base data-type</li>
<li>Non-constant multiples of the base data-type</li>
<li>An constant offset to a sub-component of the base data-type</li>
<li>An remaining terms</li>
</ul>
<p>The <em>multiple</em> terms are rewritten using a CPUI_PTRADD. The constant offset is rewritten using a CPUI_PTRSUB. Other terms are added back in. Analysis may cause multiplication (CPUI_INT_MULT) by a constant to be distributed to its CPUI_INT_ADD input. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1fba7b1b0b2a97ada10a8a59ab2e6cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AddTreeState::apply </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to transform the pointer expression. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a transform was applied </dd></dl>

<p class="reference">References <a class="el" href="classAddTreeState.html#a55e2c67486167d2077bff227c2ebc136">baseOp</a>, <a class="el" href="classAddTreeState.html#a2c93f07dbbb6152187d0111ee2c3374e">buildDegenerate()</a>, <a class="el" href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">buildTree()</a>, <a class="el" href="classAddTreeState.html#a4703469da7955c4df9c11ec8872a7604">calcSubtype()</a>, <a class="el" href="classAddTreeState.html#aadb9ea80291a7506d29331ad2fb0d5f6">clear()</a>, <a class="el" href="classFuncdata.html#a5027da6d3c7a05a262e332b0c22c7c43">Funcdata::collapseIntMultMult()</a>, <a class="el" href="classAddTreeState.html#ad2ad5d874a5453682ddd72058476add4">data</a>, <a class="el" href="classFuncdata.html#a1b94fb7b2f8e72df053f4d09d48cdf7b">Funcdata::distributeIntMultAdd()</a>, <a class="el" href="classAddTreeState.html#aaf5ba0f36d298e714b6d225d32b3dcbb">distributeOp</a>, <a class="el" href="classAddTreeState.html#a4a2d0ce2fb20f76f64cb5c6aafd51204">isDegenerate</a>, <a class="el" href="classAddTreeState.html#a7b979fc2578a1f8c6d1801fdf79d5f4a">isDistributeUsed</a>, <a class="el" href="classAddTreeState.html#a02abd1fcfed7249def1749088b2cec1f">preventDistribution</a>, <a class="el" href="classAddTreeState.html#afd3444f0e74e13ce9f6cfc5c7b5017ba">spanAddTree()</a>, <a class="el" href="classAddTreeState.html#aac866a2b0c8bd9cb9e30840195a70293">valid</a>, and <a class="el" href="classFuncdata.html#a87967b12187406a7fdf311cc4b836118">Funcdata::warningHeader()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRulePtrArith.html#a8b6d5d16ceb0884f97bebd712b9f6852">RulePtrArith::applyOp()</a>.</p>

</div>
</div>
<a id="a2c93f07dbbb6152187d0111ee2c3374e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c93f07dbbb6152187d0111ee2c3374e">&#9670;&nbsp;</a></span>buildDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddTreeState::buildDegenerate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform ADD into degenerate PTRADD. </p>
<p>The base data-type being pointed to is unit sized (or smaller). Everything is a multiple, so an ADD is always converted into a PTRADD. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> if the degenerate transform was applied </dd></dl>

<p class="reference">References <a class="el" href="classAddTreeState.html#a55e2c67486167d2077bff227c2ebc136">baseOp</a>, <a class="el" href="classAddTreeState.html#a9eed9d205c5068f8d2c6ec8d8b7c6c17">baseType</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a148cdebda954b28dbd249f8ad3f32142">CPUI_PTRADD</a>, <a class="el" href="classAddTreeState.html#ae4d5562dcb2c9feb9161e09388b29e0a">ct</a>, <a class="el" href="classAddTreeState.html#ad2ad5d874a5453682ddd72058476add4">data</a>, <a class="el" href="classPcodeOp.html#a3bf80a4ef518e6a41cc0f0e8ae08e7b4">PcodeOp::getSlot()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#adcad3bfd56955103a031fa6d0e78acec">Funcdata::opSetAllInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, <a class="el" href="classAddTreeState.html#a18bd4ef288bdc8a93a620c4aec983668">ptr</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">apply()</a>.</p>

</div>
</div>
<a id="a406b886ea345f99dd568813650c73f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406b886ea345f99dd568813650c73f0f">&#9670;&nbsp;</a></span>buildExtra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * AddTreeState::buildExtra </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build part of tree not accounted for by multiples or <em>offset</em>. </p>
<p>Create a subtree summing all the elements that aren't multiples of the base data-type size. Correct for any double counting of non-multiple constants. Return the final <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> holding the sum or null if there are no terms. </p><dl class="section return"><dt>Returns</dt><dd>the final <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> or null </dd></dl>

<p class="reference">References <a class="el" href="classAddTreeState.html#a55e2c67486167d2077bff227c2ebc136">baseOp</a>, <a class="el" href="classAddTreeState.html#a9a339fd19b13515ab9b6d61296428633">correct</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="classAddTreeState.html#ad2ad5d874a5453682ddd72058476add4">data</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">Funcdata::newOpBefore()</a>, <a class="el" href="classAddTreeState.html#ac11cb69f9f85a57c23ddd3fe369bfbff">nonmult</a>, <a class="el" href="classAddTreeState.html#a4618ca137eb23d6751899ae86aedb989">offset</a>, <a class="el" href="classAddTreeState.html#a86c35148b6056028a64505e790c91ad8">ptrmask</a>, <a class="el" href="classAddTreeState.html#a9cfd9dac82898583c495af68a3abc07c">ptrsize</a>, and <a class="el" href="address_8hh.html#a78cde28c4eada28e12fe0dbdfb840753">uintb_negate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">buildTree()</a>.</p>

</div>
</div>
<a id="a8e8a6c35f777edd060cfd319382bfeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8a6c35f777edd060cfd319382bfeec">&#9670;&nbsp;</a></span>buildMultiples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * AddTreeState::buildMultiples </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build part of tree that is multiple of base size. </p>
<p>Construct part of the tree that sums to a multiple of the base data-type size. This value will be added to the base pointer as a CPUI_PTRADD. The final <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> produced by the sum is returned. If there are no multiples, null is returned. </p><dl class="section return"><dt>Returns</dt><dd>the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> of the multiple tree or null </dd></dl>

<p class="reference">References <a class="el" href="classAddTreeState.html#a55e2c67486167d2077bff227c2ebc136">baseOp</a>, <a class="el" href="classAddTreeState.html#aa3516e22467cf77aefe32c9e7f209767">coeff</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af4e88fc0408c2594dae2615b093aa68b">CPUI_INT_MULT</a>, <a class="el" href="classAddTreeState.html#ad2ad5d874a5453682ddd72058476add4">data</a>, <a class="el" href="classAddTreeState.html#a33cf1a3308a896062f44f575c79bb161">multiple</a>, <a class="el" href="classAddTreeState.html#acbfd064f5fab88778d1a82d6e1bf210c">multsum</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">Funcdata::newOpBefore()</a>, <a class="el" href="classAddTreeState.html#a86c35148b6056028a64505e790c91ad8">ptrmask</a>, <a class="el" href="classAddTreeState.html#a9cfd9dac82898583c495af68a3abc07c">ptrsize</a>, <a class="el" href="address_8hh.html#a6f16b447a8d8851178b1f0709c14bde6">sign_extend()</a>, and <a class="el" href="classAddTreeState.html#a535bcd4be85c95843d2cae3572e027a3">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">buildTree()</a>.</p>

</div>
</div>
<a id="a8f392e1525b28ab09bfda8c210bff22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f392e1525b28ab09bfda8c210bff22e">&#9670;&nbsp;</a></span>buildTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddTreeState::buildTree </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the transformed ADD tree. </p>
<p>The original ADD tree has been successfully split into <em>multiple</em> and <em>non-multiple</em> pieces. Rewrite the tree as a pointer expression, putting any <em>multiple</em> pieces into a PTRADD operation, creating a PTRSUB if a sub data-type offset has been calculated, and preserving and remaining terms. </p>

<p class="reference">References <a class="el" href="classAddTreeState.html#a55e2c67486167d2077bff227c2ebc136">baseOp</a>, <a class="el" href="classAddTreeState.html#a0bf3a3f869268cebf3915efeb86321b2">baseSlot</a>, <a class="el" href="classAddTreeState.html#a406b886ea345f99dd568813650c73f0f">buildExtra()</a>, <a class="el" href="classAddTreeState.html#a8e8a6c35f777edd060cfd319382bfeec">buildMultiples()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a148cdebda954b28dbd249f8ad3f32142">CPUI_PTRADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7acd169003bfcb2e8dde0cb2dc1f534449">CPUI_PTRSUB</a>, <a class="el" href="classAddTreeState.html#ae4d5562dcb2c9feb9161e09388b29e0a">ct</a>, <a class="el" href="classAddTreeState.html#ad2ad5d874a5453682ddd72058476add4">data</a>, <a class="el" href="classFuncdata.html#ae4b5e2fc80db792b976e8070e93fe49a">Funcdata::inheritReadResolution()</a>, <a class="el" href="classAddTreeState.html#abcbaaa799adf8efd5b70948a5245c0b1">isSubtype</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">Funcdata::newOpBefore()</a>, <a class="el" href="classAddTreeState.html#a4618ca137eb23d6751899ae86aedb989">offset</a>, <a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">Funcdata::opDestroy()</a>, <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">Funcdata::opSetOutput()</a>, <a class="el" href="classAddTreeState.html#aed976b05bd05c54f2dc07128eadb68cd">pRelType</a>, <a class="el" href="classAddTreeState.html#a18bd4ef288bdc8a93a620c4aec983668">ptr</a>, <a class="el" href="classAddTreeState.html#a86c35148b6056028a64505e790c91ad8">ptrmask</a>, <a class="el" href="classAddTreeState.html#a9cfd9dac82898583c495af68a3abc07c">ptrsize</a>, <a class="el" href="classAddTreeState.html#a535bcd4be85c95843d2cae3572e027a3">size</a>, and <a class="el" href="classFuncdata.html#a19698f34a432f84d8cbe94f8e0ad20d4">Funcdata::warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">apply()</a>.</p>

</div>
</div>
<a id="a4703469da7955c4df9c11ec8872a7604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4703469da7955c4df9c11ec8872a7604">&#9670;&nbsp;</a></span>calcSubtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddTreeState::calcSubtype </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate final sub-type offset. </p>
<p>Make final calcultions to determine if a pointer to a sub data-type of the base data-type is being calculated, which will result in a CPUI_PTRSUB being generated. </p>

<p class="reference">References <a class="el" href="classAddrSpace.html#af5925a4ae67a290f59bf17533fac62b4">AddrSpace::addressToByte()</a>, <a class="el" href="classAddTreeState.html#a9eed9d205c5068f8d2c6ec8d8b7c6c17">baseType</a>, <a class="el" href="classAddrSpace.html#a3c9149df492bdcaccc208eac261e8365">AddrSpace::byteToAddress()</a>, <a class="el" href="classAddTreeState.html#a9a339fd19b13515ab9b6d61296428633">correct</a>, <a class="el" href="classAddTreeState.html#ae4d5562dcb2c9feb9161e09388b29e0a">ct</a>, <a class="el" href="classTypePointerRel.html#a896cd5c9d145a964bf5587d8c99c9e8e">TypePointerRel::evaluateThruParent()</a>, <a class="el" href="classAddTreeState.html#aeedff321c0b98b2861dc69e3e55d4587">findArrayHint()</a>, <a class="el" href="classTypePointerRel.html#ad1a98fe367f8322c6b3174904194ba30">TypePointerRel::getPointerOffset()</a>, <a class="el" href="classAddTreeState.html#acc50e0482c67c1c00315a04ad982a8d2">hasMatchingSubType()</a>, <a class="el" href="classAddTreeState.html#abcbaaa799adf8efd5b70948a5245c0b1">isSubtype</a>, <a class="el" href="classAddTreeState.html#a33cf1a3308a896062f44f575c79bb161">multiple</a>, <a class="el" href="classAddTreeState.html#acbfd064f5fab88778d1a82d6e1bf210c">multsum</a>, <a class="el" href="classAddTreeState.html#ac11cb69f9f85a57c23ddd3fe369bfbff">nonmult</a>, <a class="el" href="classAddTreeState.html#a0673da5a1c73b83c06a96730b3676778">nonmultsum</a>, <a class="el" href="classAddTreeState.html#a4618ca137eb23d6751899ae86aedb989">offset</a>, <a class="el" href="classAddTreeState.html#aed976b05bd05c54f2dc07128eadb68cd">pRelType</a>, <a class="el" href="classAddTreeState.html#a86c35148b6056028a64505e790c91ad8">ptrmask</a>, <a class="el" href="classAddTreeState.html#a9cfd9dac82898583c495af68a3abc07c">ptrsize</a>, <a class="el" href="address_8hh.html#a6f16b447a8d8851178b1f0709c14bde6">sign_extend()</a>, <a class="el" href="classAddTreeState.html#a535bcd4be85c95843d2cae3572e027a3">size</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fae8e2fb69af09eb8907e86b16ff585324">TYPE_SPACEBASE</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa9001cd1bc103bb1d664228d46715f65c">TYPE_STRUCT</a>, and <a class="el" href="classAddTreeState.html#aac866a2b0c8bd9cb9e30840195a70293">valid</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">apply()</a>.</p>

</div>
</div>
<a id="a2300dc2f7b523f2e5ffce74b2cffd6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2300dc2f7b523f2e5ffce74b2cffd6cb">&#9670;&nbsp;</a></span>checkMultTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddTreeState::checkMultTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>treeCoeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulate details of INT_MULT term and continue traversal if appropriate. </p>
<p>Examine a CPUI_INT_MULT element in the middle of the add tree. Determine if we treat the output simply as a leaf, or if the multiply needs to be distributed to an additive subtree. If the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is a leaf of the tree, return <b>true</b> if it is considered a multiple of the base data-type size. If the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is the root of another additive sub-tree, return <b>true</b> if no sub-node is a multiple. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> of the operation </td></tr>
    <tr><td class="paramname">op</td><td>is the CPUI_INT_MULT operation </td></tr>
    <tr><td class="paramname">treeCoeff</td><td>is constant multiple being applied to the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there are no multiples of the base data-type size discovered </dd></dl>

<p class="reference">References <a class="el" href="classAddTreeState.html#aa3516e22467cf77aefe32c9e7f209767">coeff</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="classAddTreeState.html#aaf5ba0f36d298e714b6d225d32b3dcbb">distributeOp</a>, <a class="el" href="classAddTreeState.html#a7b979fc2578a1f8c6d1801fdf79d5f4a">isDistributeUsed</a>, <a class="el" href="classAddTreeState.html#a33cf1a3308a896062f44f575c79bb161">multiple</a>, <a class="el" href="classAddTreeState.html#a02abd1fcfed7249def1749088b2cec1f">preventDistribution</a>, <a class="el" href="classAddTreeState.html#a86c35148b6056028a64505e790c91ad8">ptrmask</a>, <a class="el" href="address_8hh.html#a6f16b447a8d8851178b1f0709c14bde6">sign_extend()</a>, <a class="el" href="classAddTreeState.html#a535bcd4be85c95843d2cae3572e027a3">size</a>, <a class="el" href="classAddTreeState.html#afd3444f0e74e13ce9f6cfc5c7b5017ba">spanAddTree()</a>, and <a class="el" href="classAddTreeState.html#aac866a2b0c8bd9cb9e30840195a70293">valid</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#aa761a9df6d8565da907989a6ab7fbc83">checkTerm()</a>.</p>

</div>
</div>
<a id="aa761a9df6d8565da907989a6ab7fbc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa761a9df6d8565da907989a6ab7fbc83">&#9670;&nbsp;</a></span>checkTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddTreeState::checkTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>treeCoeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulate details of given term and continue tree traversal. </p>
<p>If the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is a constant or multiplicative term, update totals. If the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> is additive, traverse its sub-terms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> term </td></tr>
    <tr><td class="paramname">treeCoeff</td><td>is a constant multiple applied to the entire sub-tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the sub-tree rooted at the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size.">Varnode</a> contains no multiples </dd></dl>

<p class="reference">References <a class="el" href="classAddTreeState.html#a9eed9d205c5068f8d2c6ec8d8b7c6c17">baseType</a>, <a class="el" href="classAddTreeState.html#a2300dc2f7b523f2e5ffce74b2cffd6cb">checkMultTerm()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af4e88fc0408c2594dae2615b093aa68b">CPUI_INT_MULT</a>, <a class="el" href="classAddTreeState.html#a7b979fc2578a1f8c6d1801fdf79d5f4a">isDistributeUsed</a>, <a class="el" href="classAddTreeState.html#acbfd064f5fab88778d1a82d6e1bf210c">multsum</a>, <a class="el" href="classAddTreeState.html#a0673da5a1c73b83c06a96730b3676778">nonmultsum</a>, <a class="el" href="classAddTreeState.html#a18bd4ef288bdc8a93a620c4aec983668">ptr</a>, <a class="el" href="classAddTreeState.html#a86c35148b6056028a64505e790c91ad8">ptrmask</a>, <a class="el" href="address_8hh.html#a6f16b447a8d8851178b1f0709c14bde6">sign_extend()</a>, <a class="el" href="classAddTreeState.html#a535bcd4be85c95843d2cae3572e027a3">size</a>, <a class="el" href="classAddTreeState.html#afd3444f0e74e13ce9f6cfc5c7b5017ba">spanAddTree()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa9001cd1bc103bb1d664228d46715f65c">TYPE_STRUCT</a>, and <a class="el" href="classAddTreeState.html#aac866a2b0c8bd9cb9e30840195a70293">valid</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#afd3444f0e74e13ce9f6cfc5c7b5017ba">spanAddTree()</a>.</p>

</div>
</div>
<a id="aeedff321c0b98b2861dc69e3e55d4587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedff321c0b98b2861dc69e3e55d4587">&#9670;&nbsp;</a></span>findArrayHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 AddTreeState::findArrayHint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look for evidence of an array in a sub-component. </p>
<p>Even if the current base data-type is not an array, the pointer expression may incorporate an array access for a sub component. This manifests as a non-constant non-multiple terms in the tree. If this term is itself defined by a CPUI_INT_MULT with a constant, the constant indicates a likely element size. Return a non-zero value, the likely element size, if there is evidence of a non-constant non-multiple term. Return zero otherwise. </p><dl class="section return"><dt>Returns</dt><dd>a non-zero value indicating likely element size, or zero </dd></dl>

<p class="reference">References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af4e88fc0408c2594dae2615b093aa68b">CPUI_INT_MULT</a>, <a class="el" href="classAddTreeState.html#ac11cb69f9f85a57c23ddd3fe369bfbff">nonmult</a>, and <a class="el" href="address_8hh.html#a6f16b447a8d8851178b1f0709c14bde6">sign_extend()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#a4703469da7955c4df9c11ec8872a7604">calcSubtype()</a>.</p>

</div>
</div>
<a id="acc50e0482c67c1c00315a04ad982a8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc50e0482c67c1c00315a04ad982a8d2">&#9670;&nbsp;</a></span>hasMatchingSubType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddTreeState::hasMatchingSubType </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>arrayHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb *&#160;</td>
          <td class="paramname"><em>newoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an offset into the base data-type and array hints find sub-component being referenced. </p>
<p>An explicit offset should target a specific sub data-type, but array indexing may confuse things. This method passes back the offset of the best matching component, searching among components that are <em>nearby</em> the given offset, preferring a matching array element size and a component start that is nearer to the offset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>is the given offset into the data-type </td></tr>
    <tr><td class="paramname">arrayHint</td><td>if non-zero indicates array access, where the value is the element size </td></tr>
    <tr><td class="paramname">newoff</td><td>is used to pass back the actual offset of the selected component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a good component match was found </dd></dl>

<p class="reference">References <a class="el" href="classAddTreeState.html#a9eed9d205c5068f8d2c6ec8d8b7c6c17">baseType</a>, <a class="el" href="classAddrSpace.html#a082aa8e67257bcdcfc40d1280a3d0315">AddrSpace::byteToAddressInt()</a>, <a class="el" href="classAddTreeState.html#ae4d5562dcb2c9feb9161e09388b29e0a">ct</a>, <a class="el" href="classDatatype.html#ac310ccfdc47d145f10699fa1e14e73b4">Datatype::getSubType()</a>, <a class="el" href="classDatatype.html#aa1e841435c9b1b3200c542e8ed72277c">Datatype::nearestArrayedComponentBackward()</a>, and <a class="el" href="classDatatype.html#acbb33e15f39ba19fff6235defd7a6412">Datatype::nearestArrayedComponentForward()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#a4703469da7955c4df9c11ec8872a7604">calcSubtype()</a>.</p>

</div>
</div>
<a id="adcc12ebd25e5593a37fcff5d61ef8e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc12ebd25e5593a37fcff5d61ef8e4c">&#9670;&nbsp;</a></span>initAlternateForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AddTreeState::initAlternateForm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare analysis if there is an alternate form of the base pointer. </p>
<p>For some forms of pointer (<a class="el" href="classTypePointerRel.html">TypePointerRel</a>), the pointer can be interpreted as having two versions of the data-type being pointed to. This method initializes analysis for the second version, assuming analysis of the first version has failed. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> if there is a second version that can still be analyzed </dd></dl>

<p class="reference">References <a class="el" href="classAddrSpace.html#a18aa860242e1e753b3ad786a0aa1b36e">AddrSpace::addressToByteInt()</a>, <a class="el" href="classAddTreeState.html#a9eed9d205c5068f8d2c6ec8d8b7c6c17">baseType</a>, <a class="el" href="classAddrSpace.html#a082aa8e67257bcdcfc40d1280a3d0315">AddrSpace::byteToAddressInt()</a>, <a class="el" href="classAddTreeState.html#aadb9ea80291a7506d29331ad2fb0d5f6">clear()</a>, <a class="el" href="classAddTreeState.html#ae4d5562dcb2c9feb9161e09388b29e0a">ct</a>, <a class="el" href="classAddTreeState.html#a4a2d0ce2fb20f76f64cb5c6aafd51204">isDegenerate</a>, <a class="el" href="classAddTreeState.html#aed976b05bd05c54f2dc07128eadb68cd">pRelType</a>, <a class="el" href="classAddTreeState.html#a02abd1fcfed7249def1749088b2cec1f">preventDistribution</a>, and <a class="el" href="classAddTreeState.html#a535bcd4be85c95843d2cae3572e027a3">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRulePtrArith.html#a8b6d5d16ceb0884f97bebd712b9f6852">RulePtrArith::applyOp()</a>.</p>

</div>
</div>
<a id="afd3444f0e74e13ce9f6cfc5c7b5017ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3444f0e74e13ce9f6cfc5c7b5017ba">&#9670;&nbsp;</a></span>spanAddTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddTreeState::spanAddTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>treeCoeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk the given sub-tree accumulating details. </p>
<p>Recursively walk the sub-tree from the given root. Terms that are a <em>multiple</em> of the base data-type size are accumulated either in the the sum of constant multiples or the container of non-constant multiples. Terms that are a <em>non-multiple</em> are accumulated either in the sum of constant non-multiples or the container of non-constant non-multiples. The constant non-multiples are counted twice, once in the sum, and once in the container. This routine returns <b>true</b> if no node of the sub-tree is considered a multiple of the base data-type size (or <b>false</b> if any node is considered a multiple). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the root of the sub-expression to traverse </td></tr>
    <tr><td class="paramname">treeCoeff</td><td>is a constant multiple applied to the entire additive tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the given sub-tree contains no multiple nodes </dd></dl>

<p class="reference">References <a class="el" href="classAddTreeState.html#aa761a9df6d8565da907989a6ab7fbc83">checkTerm()</a>, <a class="el" href="classAddTreeState.html#a33cf1a3308a896062f44f575c79bb161">multiple</a>, <a class="el" href="classAddTreeState.html#acbfd064f5fab88778d1a82d6e1bf210c">multsum</a>, <a class="el" href="classAddTreeState.html#ac11cb69f9f85a57c23ddd3fe369bfbff">nonmult</a>, <a class="el" href="classAddTreeState.html#a0673da5a1c73b83c06a96730b3676778">nonmultsum</a>, <a class="el" href="classAddTreeState.html#aed976b05bd05c54f2dc07128eadb68cd">pRelType</a>, <a class="el" href="classAddTreeState.html#a535bcd4be85c95843d2cae3572e027a3">size</a>, and <a class="el" href="classAddTreeState.html#aac866a2b0c8bd9cb9e30840195a70293">valid</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAddTreeState.html#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">apply()</a>, <a class="el" href="classAddTreeState.html#a2300dc2f7b523f2e5ffce74b2cffd6cb">checkMultTerm()</a>, and <a class="el" href="classAddTreeState.html#aa761a9df6d8565da907989a6ab7fbc83">checkTerm()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ruleaction_8hh.html">ruleaction.hh</a></li>
<li>ruleaction.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
